"""
Supply/Demand Zone Analysis Tool
===============================

Advanced analysis tool for identifying and tracking supply/demand zones
- Historical zone performance analysis
- Live zone strength scoring
- Zone probability calculations
- Visual zone mapping and charts

üéØ Making money through precise zone identification
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import seaborn as sns
from typing import Dict, List, Tuple, Optional
import json
import warnings
warnings.filterwarnings('ignore')

# Set style for professional charts
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette(\"husl\")

class ZoneAnalyzer:
    """Advanced supply/demand zone analysis"""
    
    def __init__(self, config_file: str = 'config.json'):
        with open(config_file, 'r') as f:
            self.config = json.load(f)
        
        # Import strategy for data access
        import sys
        sys.path.append('.')
        from index_intraday_strategy import IndexIntradayStrategy
        
        self.strategy = IndexIntradayStrategy(
            self.config['client_id'], 
            self.config['access_token']
        )
        
        # Analysis parameters
        self.zone_identification_params = {
            'volume_multiplier': 1.8,     # Volume spike threshold
            'price_tolerance': 0.3,       # % tolerance for zone boundaries
            'min_strength': 2,            # Minimum tests required
            'strong_threshold': 4,        # Strong zone threshold
            'lookback_periods': 50,       # Periods to analyze
            'proximity_threshold': 2.0    # % proximity to current price
        }\n        \n        # Trading symbols\n        self.symbols = {\n            'NIFTY': 'NSE:NIFTY50-INDEX',\n            'BANKNIFTY': 'NSE:NIFTYBANK-INDEX'\n        }\n        \n        print(\"üíé ZONE ANALYZER INITIALIZED\")\n        print(f\"üéØ Focus: Advanced supply/demand zone analysis\")\n        print(f\"üìä Symbols: {list(self.symbols.keys())}\")\n    \n    def analyze_historical_zones(self, symbol: str, days: int = 30) -> Dict:\n        \"\"\"Comprehensive historical zone analysis\"\"\"\n        \n        print(f\"\\nüìä ANALYZING HISTORICAL ZONES: {symbol}\")\n        print(f\"üìÖ Period: {days} days\")\n        print(\"-\" * 50)\n        \n        try:\n            # Get extended historical data\n            data_1h = self.strategy.get_market_data(symbol, \"60\", days=days)\n            data_5m = self.strategy.get_market_data(symbol, \"5\", days=7)  # Recent 5M for confirmation\n            \n            if data_1h.empty or data_5m.empty:\n                print(f\"‚ùå No data available for {symbol}\")\n                return {}\n            \n            data_1h = self.strategy.calculate_technical_indicators(data_1h)\n            data_5m = self.strategy.calculate_technical_indicators(data_5m)\n            \n            current_price = data_1h['close'].iloc[-1]\n            \n            # Identify all historical zones\n            supply_zones = self.identify_supply_zones(data_1h, current_price)\n            demand_zones = self.identify_demand_zones(data_1h, current_price)\n            \n            # Calculate zone statistics\n            supply_stats = self.calculate_zone_statistics(supply_zones, data_1h, 'SUPPLY')\n            demand_stats = self.calculate_zone_statistics(demand_zones, data_1h, 'DEMAND')\n            \n            # Zone performance analysis\n            supply_performance = self.analyze_zone_performance(supply_zones, data_5m, 'SUPPLY')\n            demand_performance = self.analyze_zone_performance(demand_zones, data_5m, 'DEMAND')\n            \n            analysis_results = {\n                'symbol': symbol,\n                'current_price': current_price,\n                'analysis_period': days,\n                'supply_zones': supply_zones,\n                'demand_zones': demand_zones,\n                'supply_stats': supply_stats,\n                'demand_stats': demand_stats,\n                'supply_performance': supply_performance,\n                'demand_performance': demand_performance,\n                'total_zones': len(supply_zones) + len(demand_zones),\n                'strong_zones': len([z for z in supply_zones + demand_zones if z['strength'] >= 4])\n            }\n            \n            # Display analysis summary\n            self.display_zone_analysis(analysis_results)\n            \n            return analysis_results\n            \n        except Exception as e:\n            print(f\"‚ùå Error analyzing zones for {symbol}: {e}\")\n            return {}\n    \n    def identify_supply_zones(self, data: pd.DataFrame, current_price: float) -> List[Dict]:\n        \"\"\"Identify supply zones with detailed analysis\"\"\"\n        \n        supply_zones = []\n        recent_data = data.tail(self.zone_identification_params['lookback_periods'])\n        \n        for i in range(10, len(recent_data) - 5):\n            candle = recent_data.iloc[i]\n            \n            # Supply zone conditions: High volume rejection at peak\n            if (candle['high'] == recent_data['high'].iloc[i-5:i+6].max() and\n                candle['volume'] > recent_data['volume'].iloc[i-10:i+10].mean() * self.zone_identification_params['volume_multiplier']):\n                \n                zone_level = candle['high']\n                zone_low = candle['low']  # Zone boundary\n                \n                # Count tests and calculate strength\n                tests = []\n                strength = 0\n                success_count = 0\n                \n                for j in range(i+1, len(recent_data)):\n                    test_candle = recent_data.iloc[j]\n                    zone_distance = abs(test_candle['high'] - zone_level) / zone_level * 100\n                    \n                    if zone_distance <= self.zone_identification_params['price_tolerance']:\n                        is_rejection = test_candle['close'] < test_candle['open']\n                        \n                        tests.append({\n                            'timestamp': test_candle.name,\n                            'price': test_candle['high'],\n                            'volume': test_candle['volume'],\n                            'rejection': is_rejection,\n                            'distance_pct': zone_distance\n                        })\n                        \n                        strength += 1\n                        if is_rejection:\n                            success_count += 1\n                \n                # Only include zones with minimum strength\n                if strength >= self.zone_identification_params['min_strength']:\n                    # Check proximity to current price\n                    price_distance = abs(current_price - zone_level) / current_price * 100\n                    \n                    if price_distance <= self.zone_identification_params['proximity_threshold']:\n                        success_rate = success_count / strength if strength > 0 else 0\n                        \n                        zone = {\n                            'type': 'STRONG_SUPPLY' if strength >= self.zone_identification_params['strong_threshold'] else 'SUPPLY',\n                            'level': zone_level,\n                            'zone_low': zone_low,\n                            'zone_range': zone_level - zone_low,\n                            'strength': strength,\n                            'success_count': success_count,\n                            'success_rate': success_rate,\n                            'volume': candle['volume'],\n                            'created_time': candle.name,\n                            'distance_from_current': price_distance,\n                            'tests': tests,\n                            'confidence_score': min(strength * 0.15 + success_rate * 0.4, 0.95),\n                            'profit_potential': self.calculate_profit_potential(zone_level, current_price, 'SUPPLY')\n                        }\n                        \n                        supply_zones.append(zone)\n        \n        # Sort by strength and proximity\n        supply_zones = sorted(supply_zones, key=lambda z: (z['strength'], -z['distance_from_current']), reverse=True)\n        return supply_zones\n    \n    def identify_demand_zones(self, data: pd.DataFrame, current_price: float) -> List[Dict]:\n        \"\"\"Identify demand zones with detailed analysis\"\"\"\n        \n        demand_zones = []\n        recent_data = data.tail(self.zone_identification_params['lookback_periods'])\n        \n        for i in range(10, len(recent_data) - 5):\n            candle = recent_data.iloc[i]\n            \n            # Demand zone conditions: High volume bounce at trough\n            if (candle['low'] == recent_data['low'].iloc[i-5:i+6].min() and\n                candle['volume'] > recent_data['volume'].iloc[i-10:i+10].mean() * self.zone_identification_params['volume_multiplier']):\n                \n                zone_level = candle['low']\n                zone_high = candle['high']  # Zone boundary\n                \n                # Count tests and calculate strength\n                tests = []\n                strength = 0\n                success_count = 0\n                \n                for j in range(i+1, len(recent_data)):\n                    test_candle = recent_data.iloc[j]\n                    zone_distance = abs(test_candle['low'] - zone_level) / zone_level * 100\n                    \n                    if zone_distance <= self.zone_identification_params['price_tolerance']:\n                        is_bounce = test_candle['close'] > test_candle['open']\n                        \n                        tests.append({\n                            'timestamp': test_candle.name,\n                            'price': test_candle['low'],\n                            'volume': test_candle['volume'],\n                            'bounce': is_bounce,\n                            'distance_pct': zone_distance\n                        })\n                        \n                        strength += 1\n                        if is_bounce:\n                            success_count += 1\n                \n                # Only include zones with minimum strength\n                if strength >= self.zone_identification_params['min_strength']:\n                    # Check proximity to current price\n                    price_distance = abs(current_price - zone_level) / current_price * 100\n                    \n                    if price_distance <= self.zone_identification_params['proximity_threshold']:\n                        success_rate = success_count / strength if strength > 0 else 0\n                        \n                        zone = {\n                            'type': 'STRONG_DEMAND' if strength >= self.zone_identification_params['strong_threshold'] else 'DEMAND',\n                            'level': zone_level,\n                            'zone_high': zone_high,\n                            'zone_range': zone_high - zone_level,\n                            'strength': strength,\n                            'success_count': success_count,\n                            'success_rate': success_rate,\n                            'volume': candle['volume'],\n                            'created_time': candle.name,\n                            'distance_from_current': price_distance,\n                            'tests': tests,\n                            'confidence_score': min(strength * 0.15 + success_rate * 0.4, 0.95),\n                            'profit_potential': self.calculate_profit_potential(zone_level, current_price, 'DEMAND')\n                        }\n                        \n                        demand_zones.append(zone)\n        \n        # Sort by strength and proximity\n        demand_zones = sorted(demand_zones, key=lambda z: (z['strength'], -z['distance_from_current']), reverse=True)\n        return demand_zones\n    \n    def calculate_zone_statistics(self, zones: List[Dict], data: pd.DataFrame, zone_type: str) -> Dict:\n        \"\"\"Calculate comprehensive zone statistics\"\"\"\n        \n        if not zones:\n            return {\n                'total_zones': 0,\n                'strong_zones': 0,\n                'average_strength': 0,\n                'average_success_rate': 0,\n                'best_zone_confidence': 0,\n                'zones_near_current': 0\n            }\n        \n        strong_zones = [z for z in zones if z['strength'] >= 4]\n        zones_near_current = [z for z in zones if z['distance_from_current'] <= 0.5]\n        \n        return {\n            'total_zones': len(zones),\n            'strong_zones': len(strong_zones),\n            'average_strength': np.mean([z['strength'] for z in zones]),\n            'average_success_rate': np.mean([z['success_rate'] for z in zones]),\n            'best_zone_confidence': max([z['confidence_score'] for z in zones]),\n            'zones_near_current': len(zones_near_current),\n            'average_profit_potential': np.mean([z['profit_potential'] for z in zones])\n        }\n    \n    def calculate_profit_potential(self, zone_level: float, current_price: float, zone_type: str) -> float:\n        \"\"\"Calculate profit potential from zone level\"\"\"\n        \n        if zone_type == 'SUPPLY':\n            # For supply zones, profit from selling near zone and buying lower\n            return max(zone_level - current_price, 0)\n        else:\n            # For demand zones, profit from buying near zone and selling higher\n            return max(current_price - zone_level, 0)\n    \n    def analyze_zone_performance(self, zones: List[Dict], data_5m: pd.DataFrame, zone_type: str) -> Dict:\n        \"\"\"Analyze how zones have performed in recent 5M data\"\"\"\n        \n        if not zones:\n            return {\n                'zones_tested_recently': 0,\n                'successful_tests': 0,\n                'failed_tests': 0,\n                'average_reaction_strength': 0\n            }\n        \n        zones_tested = 0\n        successful_tests = 0\n        failed_tests = 0\n        reaction_strengths = []\n        \n        # Check recent 5M data for zone interactions\n        for zone in zones:\n            zone_level = zone['level']\n            recent_tests = 0\n            recent_successes = 0\n            \n            for _, candle in data_5m.iterrows():\n                if zone_type == 'SUPPLY':\n                    distance = abs(candle['high'] - zone_level) / zone_level * 100\n                    if distance <= 0.2:  # Very close to zone\n                        recent_tests += 1\n                        if candle['close'] < candle['open']:  # Rejection\n                            recent_successes += 1\n                            reaction_strength = abs(candle['open'] - candle['close']) / candle['open'] * 100\n                            reaction_strengths.append(reaction_strength)\n                        else:\n                            failed_tests += 1\n                else:  # DEMAND\n                    distance = abs(candle['low'] - zone_level) / zone_level * 100\n                    if distance <= 0.2:  # Very close to zone\n                        recent_tests += 1\n                        if candle['close'] > candle['open']:  # Bounce\n                            recent_successes += 1\n                            reaction_strength = abs(candle['close'] - candle['open']) / candle['open'] * 100\n                            reaction_strengths.append(reaction_strength)\n                        else:\n                            failed_tests += 1\n            \n            if recent_tests > 0:\n                zones_tested += 1\n                successful_tests += recent_successes\n        \n        return {\n            'zones_tested_recently': zones_tested,\n            'successful_tests': successful_tests,\n            'failed_tests': failed_tests,\n            'success_rate_recent': successful_tests / max(successful_tests + failed_tests, 1),\n            'average_reaction_strength': np.mean(reaction_strengths) if reaction_strengths else 0\n        }\n    \n    def display_zone_analysis(self, analysis: Dict):\n        \"\"\"Display comprehensive zone analysis\"\"\"\n        \n        symbol = analysis['symbol']\n        current_price = analysis['current_price']\n        \n        print(f\"\\nüíé ZONE ANALYSIS RESULTS: {symbol}\")\n        print(f\"üí∞ Current Price: ‚Çπ{current_price:.2f}\")\n        print(f\"=\"*60)\n        \n        # Supply zones analysis\n        print(f\"\\nüî¥ SUPPLY ZONES ANALYSIS:\")\n        print(\"-\" * 40)\n        supply_stats = analysis['supply_stats']\n        print(f\"   Total Zones: {supply_stats['total_zones']}\")\n        print(f\"   Strong Zones: {supply_stats['strong_zones']}\")\n        print(f\"   Average Strength: {supply_stats['average_strength']:.1f}\")\n        print(f\"   Average Success Rate: {supply_stats['average_success_rate']:.1%}\")\n        print(f\"   Zones Near Current Price: {supply_stats['zones_near_current']}\")\n        \n        if analysis['supply_zones']:\n            print(f\"\\n   üìä TOP SUPPLY ZONES:\")\n            for i, zone in enumerate(analysis['supply_zones'][:3]):\n                strength_indicator = \"üíé\" if zone['strength'] >= 4 else \"‚≠ê\"\n                print(f\"   {i+1}. {strength_indicator} ‚Çπ{zone['level']:.2f} | Strength: {zone['strength']} | Success: {zone['success_rate']:.1%} | Distance: {zone['distance_from_current']:.2f}%\")\n        \n        # Demand zones analysis\n        print(f\"\\nüü¢ DEMAND ZONES ANALYSIS:\")\n        print(\"-\" * 40)\n        demand_stats = analysis['demand_stats']\n        print(f\"   Total Zones: {demand_stats['total_zones']}\")\n        print(f\"   Strong Zones: {demand_stats['strong_zones']}\")\n        print(f\"   Average Strength: {demand_stats['average_strength']:.1f}\")\n        print(f\"   Average Success Rate: {demand_stats['average_success_rate']:.1%}\")\n        print(f\"   Zones Near Current Price: {demand_stats['zones_near_current']}\")\n        \n        if analysis['demand_zones']:\n            print(f\"\\n   üìä TOP DEMAND ZONES:\")\n            for i, zone in enumerate(analysis['demand_zones'][:3]):\n                strength_indicator = \"üíé\" if zone['strength'] >= 4 else \"‚≠ê\"\n                print(f\"   {i+1}. {strength_indicator} ‚Çπ{zone['level']:.2f} | Strength: {zone['strength']} | Success: {zone['success_rate']:.1%} | Distance: {zone['distance_from_current']:.2f}%\")\n        \n        # Performance analysis\n        print(f\"\\nüìà RECENT PERFORMANCE:\")\n        print(\"-\" * 30)\n        supply_perf = analysis['supply_performance']\n        demand_perf = analysis['demand_performance']\n        \n        print(f\"   Supply Zones Tested: {supply_perf['zones_tested_recently']}\")\n        print(f\"   Supply Success Rate: {supply_perf['success_rate_recent']:.1%}\")\n        print(f\"   Demand Zones Tested: {demand_perf['zones_tested_recently']}\")\n        print(f\"   Demand Success Rate: {demand_perf['success_rate_recent']:.1%}\")\n        \n        # Trading recommendations\n        self.generate_trading_recommendations(analysis)\n    \n    def generate_trading_recommendations(self, analysis: Dict):\n        \"\"\"Generate trading recommendations based on zone analysis\"\"\"\n        \n        print(f\"\\nüí° TRADING RECOMMENDATIONS:\")\n        print(\"-\" * 40)\n        \n        symbol = analysis['symbol']\n        current_price = analysis['current_price']\n        supply_zones = analysis['supply_zones']\n        demand_zones = analysis['demand_zones']\n        \n        recommendations = []\n        \n        # Check for immediate trading opportunities\n        for zone in supply_zones[:2]:  # Top 2 supply zones\n            if zone['distance_from_current'] <= 0.5 and zone['confidence_score'] >= 0.8:\n                recommendations.append({\n                    'type': 'SELL_SETUP',\n                    'zone': zone,\n                    'reason': f\"Price near strong supply zone with {zone['success_rate']:.1%} success rate\"\n                })\n        \n        for zone in demand_zones[:2]:  # Top 2 demand zones\n            if zone['distance_from_current'] <= 0.5 and zone['confidence_score'] >= 0.8:\n                recommendations.append({\n                    'type': 'BUY_SETUP',\n                    'zone': zone,\n                    'reason': f\"Price near strong demand zone with {zone['success_rate']:.1%} success rate\"\n                })\n        \n        if recommendations:\n            for i, rec in enumerate(recommendations):\n                action_icon = \"üìà\" if rec['type'] == 'BUY_SETUP' else \"üìâ\"\n                zone = rec['zone']\n                print(f\"   {i+1}. {action_icon} {rec['type']}: ‚Çπ{zone['level']:.2f}\")\n                print(f\"      üéØ {rec['reason']}\")\n                print(f\"      üí™ Confidence: {zone['confidence_score']:.1%}\")\n                print(f\"      üìä Expected Profit: ‚Çπ{zone['profit_potential']:.2f}\")\n        else:\n            print(f\"   ‚è≥ No immediate high-confidence setups\")\n            print(f\"   üëÄ Monitor zones for price approach opportunities\")\n        \n        # General market sentiment from zones\n        print(f\"\\nüìä MARKET SENTIMENT FROM ZONES:\")\n        if len(supply_zones) > len(demand_zones):\n            print(f\"   üî¥ Bearish bias: More supply zones active\")\n        elif len(demand_zones) > len(supply_zones):\n            print(f\"   üü¢ Bullish bias: More demand zones active\")\n        else:\n            print(f\"   ‚ö™ Neutral: Balanced supply/demand zones\")\n    \n    def create_zone_chart(self, symbol: str, analysis_data: Dict = None, save: bool = True):\n        \"\"\"Create visual chart showing supply/demand zones\"\"\"\n        \n        if not analysis_data:\n            analysis_data = self.analyze_historical_zones(symbol, days=15)\n        \n        try:\n            # Get chart data\n            data = self.strategy.get_market_data(symbol, \"60\", days=15)\n            if data.empty:\n                print(f\"‚ùå No data for chart creation\")\n                return\n            \n            data = self.strategy.calculate_technical_indicators(data)\n            \n            # Create figure\n            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 12), height_ratios=[3, 1])\n            \n            # Main price chart\n            ax1.plot(data.index, data['close'], linewidth=2, label='Price', color='black')\n            \n            current_price = data['close'].iloc[-1]\n            \n            # Plot supply zones\n            for zone in analysis_data.get('supply_zones', []):\n                if zone['distance_from_current'] <= 2.0:  # Only nearby zones\n                    zone_color = 'red' if zone['type'] == 'STRONG_SUPPLY' else 'orange'\n                    alpha = 0.7 if zone['strength'] >= 4 else 0.4\n                    \n                    ax1.axhline(y=zone['level'], color=zone_color, linestyle='--', alpha=alpha, linewidth=2)\n                    \n                    # Add zone rectangle\n                    rect = patches.Rectangle(\n                        (data.index[0], zone['zone_low']), \n                        len(data.index), \n                        zone['zone_range'],\n                        linewidth=0, \n                        edgecolor='none',\n                        facecolor=zone_color, \n                        alpha=0.1\n                    )\n                    ax1.add_patch(rect)\n                    \n                    # Label\n                    ax1.text(data.index[-10], zone['level'], \n                            f'S{zone[\"strength\"]} ({zone[\"success_rate\"]:.0%})', \n                            color=zone_color, fontweight='bold', fontsize=8)\n            \n            # Plot demand zones\n            for zone in analysis_data.get('demand_zones', []):\n                if zone['distance_from_current'] <= 2.0:  # Only nearby zones\n                    zone_color = 'green' if zone['type'] == 'STRONG_DEMAND' else 'lightgreen'\n                    alpha = 0.7 if zone['strength'] >= 4 else 0.4\n                    \n                    ax1.axhline(y=zone['level'], color=zone_color, linestyle='--', alpha=alpha, linewidth=2)\n                    \n                    # Add zone rectangle\n                    rect = patches.Rectangle(\n                        (data.index[0], zone['level']), \n                        len(data.index), \n                        zone['zone_range'],\n                        linewidth=0, \n                        edgecolor='none',\n                        facecolor=zone_color, \n                        alpha=0.1\n                    )\n                    ax1.add_patch(rect)\n                    \n                    # Label\n                    ax1.text(data.index[-10], zone['level'], \n                            f'D{zone[\"strength\"]} ({zone[\"success_rate\"]:.0%})', \n                            color=zone_color, fontweight='bold', fontsize=8)\n            \n            # Current price line\n            ax1.axhline(y=current_price, color='blue', linewidth=2, alpha=0.8, label=f'Current: ‚Çπ{current_price:.2f}')\n            \n            # Chart formatting\n            ax1.set_title(f'{symbol} - Supply/Demand Zone Analysis', fontsize=16, fontweight='bold')\n            ax1.set_ylabel('Price (‚Çπ)', fontsize=12)\n            ax1.legend(loc='upper left')\n            ax1.grid(True, alpha=0.3)\n            \n            # Volume chart\n            ax2.bar(data.index, data['volume'], alpha=0.6, color='gray')\n            ax2.set_ylabel('Volume', fontsize=12)\n            ax2.set_xlabel('Time', fontsize=12)\n            \n            plt.tight_layout()\n            \n            if save:\n                filename = f\"zone_analysis_{symbol.replace(':', '_')}_{datetime.now().strftime('%Y%m%d_%H%M')}.png\"\n                plt.savefig(filename, dpi=300, bbox_inches='tight')\n                print(f\"üìä Chart saved: {filename}\")\n            \n            plt.show()\n            \n        except Exception as e:\n            print(f\"‚ùå Error creating zone chart: {e}\")\n    \n    def run_complete_analysis(self, symbol: str = None):\n        \"\"\"Run complete zone analysis for specified symbol or all symbols\"\"\"\n        \n        symbols_to_analyze = [symbol] if symbol else list(self.symbols.keys())\n        \n        print(f\"üíé RUNNING COMPLETE ZONE ANALYSIS\")\n        print(f\"üìä Symbols: {', '.join(symbols_to_analyze)}\")\n        print(f\"=\"*60)\n        \n        analysis_results = {}\n        \n        for symbol_name in symbols_to_analyze:\n            symbol_code = self.symbols[symbol_name]\n            \n            print(f\"\\nüîç Analyzing {symbol_name}...\")\n            analysis = self.analyze_historical_zones(symbol_code, days=30)\n            \n            if analysis:\n                analysis_results[symbol_name] = analysis\n                \n                # Create chart\n                print(f\"üìà Creating zone chart for {symbol_name}...\")\n                self.create_zone_chart(symbol_code, analysis, save=True)\n            \n            print(f\"‚úÖ Analysis complete for {symbol_name}\")\n        \n        # Summary comparison\n        if len(analysis_results) > 1:\n            self.compare_symbol_zones(analysis_results)\n        \n        return analysis_results\n    \n    def compare_symbol_zones(self, analysis_results: Dict):\n        \"\"\"Compare zone analysis across symbols\"\"\"\n        \n        print(f\"\\nüìä CROSS-SYMBOL ZONE COMPARISON\")\n        print(f\"=\"*50)\n        \n        for symbol_name, analysis in analysis_results.items():\n            supply_stats = analysis['supply_stats']\n            demand_stats = analysis['demand_stats']\n            \n            print(f\"\\nüìà {symbol_name}:\")\n            print(f\"   üî¥ Supply: {supply_stats['total_zones']} zones ({supply_stats['strong_zones']} strong)\")\n            print(f\"   üü¢ Demand: {demand_stats['total_zones']} zones ({demand_stats['strong_zones']} strong)\")\n            print(f\"   üí™ Best Confidence: {max(supply_stats['best_zone_confidence'], demand_stats['best_zone_confidence']):.1%}\")\n            \n            # Determine bias\n            if supply_stats['total_zones'] > demand_stats['total_zones']:\n                bias = \"üìâ Bearish\"\n            elif demand_stats['total_zones'] > supply_stats['total_zones']:\n                bias = \"üìà Bullish\"\n            else:\n                bias = \"‚ö™ Neutral\"\n            \n            print(f\"   üéØ Bias: {bias}\")\n\ndef main():\n    \"\"\"Main function for zone analysis\"\"\"\n    \n    print(f\"üíé SUPPLY/DEMAND ZONE ANALYZER\")\n    print(f\"üéØ Advanced zone identification and analysis\")\n    print(f\"=\"*50)\n    \n    try:\n        analyzer = ZoneAnalyzer()\n        \n        print(f\"\\nüìä Available Analysis Options:\")\n        print(f\"   1. Complete analysis (all symbols with charts)\")\n        print(f\"   2. Single symbol analysis\")\n        print(f\"   3. Custom analysis\")\n        \n        choice = input(f\"\\nüéØ Choose analysis type (1/2/3): \")\n        \n        if choice == '1':\n            print(f\"\\nüíé Running complete analysis for all symbols...\")\n            results = analyzer.run_complete_analysis()\n            \n        elif choice == '2':\n            print(f\"\\nüìä Available symbols: {', '.join(analyzer.symbols.keys())}\")\n            symbol_choice = input(f\"üéØ Choose symbol: \").upper()\n            \n            if symbol_choice in analyzer.symbols:\n                results = analyzer.run_complete_analysis(symbol_choice)\n            else:\n                print(f\"‚ùå Invalid symbol choice\")\n                return\n                \n        elif choice == '3':\n            symbol_choice = input(f\"üìä Enter symbol (NIFTY/BANKNIFTY): \").upper()\n            days = int(input(f\"üìÖ Analysis period (days, default 30): \") or 30)\n            \n            if symbol_choice in analyzer.symbols:\n                symbol_code = analyzer.symbols[symbol_choice]\n                analysis = analyzer.analyze_historical_zones(symbol_code, days)\n                if analysis:\n                    analyzer.create_zone_chart(symbol_code, analysis, save=True)\n            else:\n                print(f\"‚ùå Invalid symbol\")\n                return\n        else:\n            print(f\"‚ùå Invalid choice\")\n            return\n        \n        print(f\"\\n‚úÖ Zone analysis completed!\")\n        print(f\"üí° Use the insights for enhanced trading decisions\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error in zone analysis: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    main()